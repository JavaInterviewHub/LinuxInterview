## 系统信息

* [1.查看Linux内核版本命令](#1查看linux内核版本命令)
* [2.查看Linux系统版本的命令](#2查看linux系统版本的命令)
* [3.Linux查看版本当前操作系统发行版信息](#3linux查看版本当前操作系统发行版信息)
* [4.查看服务器名称](#4查看服务器名称)
* [5.查看网络信息](#5查看网络信息)
* [6.查看CPU信息](#6查看cpu信息)
* [7.列出所有PCI设备](#7列出所有pci设备)
* [8.查看环境变量](#8查看环境变量)
* [9.查看活动用户](#9查看活动用户)
* [10.列出所有系统服务](#10列出所有系统服务)
* [11.内存管理的必要性](#11内存管理的必要性)
* [12.虚拟地址](#12虚拟地址)
* [13.虚拟地址的好处](#13虚拟地址的好处)
* [14.物理地址](#14物理地址)
* [15.页的概念](#15页的概念)
* [16.swap对换空间](#16swap对换空间)
* [17.缺页中断定义](#17缺页中断定义)
* [18.缺页中断的次数](#18缺页中断的次数)
* [19.页面置换算法](#19页面置换算法)
* [20.如何杀死某个进程](#20如何杀死某个进程)
* [21. 显示内存使用情况](#21-显示内存使用情况)
* [22. 解释free -m的输出](#22-解释free--m的输出)
* [23.进程](#23进程)
* [24.列出所有运行中/激活进程](#24列出所有运行中激活进程)
* [25.列出需要进程](#25列出需要进程)
* [26.以树状结构显示进程关系](#26以树状结构显示进程关系)
* [27.杀进程的命令](#27杀进程的命令)
* [28.进程的状态](#28进程的状态)
* [29.僵尸进程](#29僵尸进程)
* [30.查看环境变量](#30查看环境变量)
* [31.孤儿进程](#31孤儿进程)
* [32.如何杀死某个进程](#32如何杀死某个进程)
* [参考链接](#参考链接)

#### 1.查看Linux内核版本命令

```css
1.uname －a   （Linux查看版本当前操作系统内核信息）
```

```undefined
2.cat /proc/version （Linux查看当前操作系统版本信息）
```

#### 2.查看Linux系统版本的命令

```undefined
1、lsb_release -a，即可列出所有版本信息：
这个命令适用于所有的Linux发行版，包括RedHat、SUSE、Debian…等发行版。
```

```csharp
2、cat /etc/redhat-release，这种方法只适合Redhat系的Linux：

[root@S-CentOS home]# cat /etc/redhat-release

CentOS release 6.5 (Final)

3、cat /etc/issue，此命令也适用于所有的Linux发行版。
```

#### 3.Linux查看版本当前操作系统发行版信息

```undefined
1.cat /etc/issue  或cat /etc/redhat-release
```

#### 4.查看服务器名称

```css
hostname 
```

#### 5.查看网络信息

```undefined
ifconfig  
```

#### 6.查看CPU信息

```
 cat /proc/cpuinfo 
```

#### 7.列出所有PCI设备

```
lspci -tv  
```

#### 8.查看环境变量

```
env                    
```

#### 9.查看活动用户

```
w 
```

#### 10.列出所有系统服务

```
chkconfig --list  
```

#### 11.内存管理的必要性

出现在早期的计算机系统当中，程序是直接运行在物理内存中，每一个程序都能直接访问物理地址。如果这个系统只运行一个程序的话，并且这个程序所需的内存不要超过该机器的物理内存就不会出现问题。但是如今的系统都是支持多任务和多进程的，那么这时我们就要考虑如何将系统内有限的物理内存及时有效的分配给多个程序了，这就是内存管理的基本概念。顾名思义就是是记录哪些内存是正在使用的，哪些内存是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存。


#### 12.虚拟地址

即使是现代操作系统中，内存依然是计算机中很宝贵的资源，看看你电脑几个T固态硬盘，再看看内存大小就知道了。为了充分利用和管理系统内存资源，Linux采用虚拟内存管理技术，利用虚拟内存技术让每个进程都有4GB 互不干涉的虚拟地址空间。

进程初始化分配和操作的都是基于这个「虚拟地址」，只有当进程需要实际访问内存资源的时候才会建立虚拟地址和物理地址的映射，调入物理内存页。

打个不是很恰当的比方。这个原理其实和现在的某某网盘一样，假如你的网盘空间是1TB，真以为就一口气给了你这么大空间吗？那还是太年轻，都是在你往里面放东西的时候才给你分配空间，你放多少就分多少实际空间给你，但你和你朋友看起来就像大家都拥有1TB空间一样。

#### 13.虚拟地址的好处

避免用户直接访问物理内存地址，防止一些破坏性操作，保护操作系统每个进程都被分配了4GB的虚拟内存，用户程序可使用比实际物理内存更大的地址空间4GB 的进程虚拟地址空间被分成两部分：「用户空间」和「内核空间」

![img](https://pics7.baidu.com/feed/d53f8794a4c27d1ee86c9e9a65ab2768dcc438ae.jpeg?token=1ec842bf2fbc89fefbd3361d71587080)

#### 14.物理地址

当需进程要实际访问内存的时候，会由内核的「请求分页机制」产生「缺页异常」调入物理内存页。

把虚拟地址转换成内存的物理地址，这中间涉及利用MMU 内存管理单元（Memory Management Unit ) 对虚拟地址分段和分页（段页式）地址转换，关于分段和分页的具体流程，这里不再赘述，可以参考任何一本计算机组成原理教材描述。

![img](https://pics6.baidu.com/feed/0df431adcbef7609ffde157053a329ca7ed99e89.jpeg?token=0edb94d1c202c527610a5f5e6cfee6bc)

Linux 内核会将物理内存分为3个管理区，分别是：

**ZONE_DMA**

DMA内存区域。包含0MB~16MB之间的内存页框，可以由老式基于ISA的设备通过DMA使用，直接映射到内核的地址空间。

**ZONE_NORMAL**

普通内存区域。包含16MB~896MB之间的内存页框，常规页框，直接映射到内核的地址空间。

**ZONE_HIGHMEM**

高端内存区域。包含896MB以上的内存页框，不进行直接映射，可以通过永久映射和临时映射进行这部分内存页框的访问。

![img](https://pics5.baidu.com/feed/14ce36d3d539b600a5488ed9972ebf2cc75cb75b.jpeg?token=69f26743428ceab0de834c19eb32566a)

**用户空间**

用户进程能访问的是「用户空间」，每个进程都有自己独立的用户空间，虚拟地址范围从从 0x00000000 至 0xBFFFFFFF 总容量3G 。

用户进程通常只能访问用户空间的虚拟地址，只有在执行内陷操作或系统调用时才能访问内核空间。

#### 15.页的概念

linux 内核中把物理页作为内存分配的最小单位，32位CPU 页的大小通常为4K，64位的CPU通常支持8K的也。内存管理单元MMU 同样以页为大小分配内存。

#### 16.swap对换空间

 32位Linux系统的每个进程可以有4 GB的虚拟 内存空间 ． 而且系统中还要同时存在多个进程 ，但是 ，事实上大多数计算机都没有这么多物理内存空间 ， 当系统中的物理内存紧缺时 ． 就需要利用对换空间把一部分未来可能不用的页面从物理内存中移 到对换设备或对换文件中。  
       Linux采用两种方式保存换出的页面 ：

       一种是利用整个块设备 ， 如硬盘的一个分区 ． 即对换设备， 
    
       另一种是利用文件系统中固定长度的文件 ． 即对换文件。 它们统称为对换空间。 
    
       这两种方式的相同之处是它们的内部格式一致． 但是在执行效率方面 ． 对换设备要好一些． 这是因为对换设备上同一页面 的数据块是连续存放的 ． 故而可以顺序存取 ， 而在对换文件中 。 同一页面的数据块实际的物理位置可能是不连续的 ． 需要通过对换文件的 inode检索． 这就降低了存取效率 。  
    
        每个对换文件或对换设备 由 struct   swap — info — struct 结构来描述。 有关对换设备的 函数主要是 get — swap — page ( …) ．    当内存中的页面需要被换出时 ． 调用 get — swap —page函数 申请得到一个对换空间中的物理页面 。 如果成功， 就返 回一个非零代 码 ． 否则返 回0。  


#### 17.缺页中断定义

当一个进程退出时，他并不是完全消失，而是等到它的符进程发出wait系统调用才会完全消失，除非父进程发出wait系统调用终止进程，否则该进程一直处于僵死状态，等待父进程终止它。
实际上，僵尸进程已经死了，它要向父进程返回一个退出状态，报告死讯。而父进程一直不进行wait系统调用的话，子进程就变成了僵尸进程。要消灭僵尸进程的话，先找到僵尸进程的父进程，杀死父进程，然后由init（进程号为1）消灭僵尸进程。init是所有进程的父进程。

#### 18.缺页中断的次数

中断次数=进程的物理块数+页面置换次数。

缺页中断率=（缺页中断次数 / 总访问页数 ）

#### 19.页面置换算法

如果父进程比子进程先死的话，子进程就变成孤儿进程了，这时候孤儿进程就被init（进程号为1）进程领养。并由init进程对他们完成状态收集工作。

#### 20.如何杀死某个进程

当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。

几种缺页中断算法（FIFO，LRU与LFU）的实现过程：
在分页虚拟存储管理的系统中，有一用户进程，它依次要访问的页面序列是序列7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1。 假定分配给该进程的页数（物理块）为3且进程初始时未装载页面（意思就是进程只能使用三块内存）。计算缺页次数和缺页率？那么采用FIFO、LRU、OPT调度算法产生的缺页中断数各为多少？缺页中断率各为多少？ 

1)、先进先出（FIFO）
优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。

利用FIFO置换算法时的置换图：

访问页面	7	0	1	2	0	3	0	4	2	3	0	3	2	1	2	0	1	7	0	1
物理块1	7	7	7	2	 	2	2	4	4	4	0	 	 	0	0	 	 	7	7	7
物理块2	 	0	0	0	 	3	3	3	2	2	2	 	 	1	1	 	 	1	0	0
物理块3	 	 	1	1	 	1	0	0	0	3	3	 	 	3	2	 	 	2	2	1
缺页否	√	√	√	√	 	√	√	√	√	√	√	 	 	√	√	 	 	√	√	
√

 

进程访问页面2时，把最早进入内存的页面7换出。然后访问页面3时，再把2, 0, 1中最先进入内存的页换出。由图可以看出，利用FIFO算法时进行了 12次页面置换。发生缺页中断的次数为15。

2)、最近最久未使用(LRU)置换算法
选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。

对上面的实例釆用LRU算法进行页面置换，如图所示。进程第一次对页面2访问时，将最近最久未被访问的页面7置换出去。然后访问页面3时，将最近最久未使用的页面1换出。

访问页面	7	0	1	2	0	3	0	4	2	3	0	3	2	1	2	0	1	7	0	1
物理块1	7	7	7	2	 	2	 	4	4	4	0	 	 	1	 	1	 	1	 	 
物理块2	 	0	0	0	 	0	 	0	0	3	3	 	 	3	 	0	 	0	 	 
物理块3	 	 	1	1	 	3	 	3	2	2	2	 	 	2	 	2	 	7	 	 
缺页否	√	√	√	√	 	√	 	√	√	√	√	 	 	√	 	√	 	√	 	 


3). 最佳置换算法(OPT)
最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。

对上面的实例釆用OPT算法进行页面置换，如图所示：

访问页面	7	0	1	2	0	3	0	4	2	3	0	3	2	1	2	0	1	7	0	1
物理块1	7	7	7	2	 	2	 	2	 	 	2	 	 	2	 	 	 	7	 	 
物理块2	 	0	0	0	 	0	 	4	 	 	0	 	 	0	 	 	 	0	 	 
物理块3	 	 	1	1	 	3	 	3	 	 	3	 	 	1	 	 	 	1	 	 
缺页否	√	 	√	√	 	√	 	√	 	 	√	 	 	√	 	 	 	√	 	 
进程运行时，先将7, 0, 1三个页面依次装入内存。进程要访问页面2时，产生缺页中断，根据最佳置换算法，选择第18次访问才需调入的页面7予以淘汰。然后，访问页面0时，因为已在内存中所以不必产生缺页中断。访问页面3时又会根据最佳置换算法将页面1淘汰……依此类推，如图所示。从图中可以看出釆用最佳置换算法时的情况。
可以看到，发生缺页中断的次数为9，页面置换的次数为6。

#### 21. 显示内存使用情况

**Linux** free[1](https://blog.csdn.net/boenxia/article/details/89642006#fn1) 命令(free) 用来显示Linux系统中空闲的、已用的物理内存及交换分区(swap)内存，及被内核使用的buffer。
其数据取自 /proc/meminfo文件。在这个文件中，数据的存储就是以KB为单位，所以free的默认值也是KB。

#### 22. 解释free -m的输出

```
-m：以MB为单位显示内存使用情况；
```

```
free -m
             total       used       free     shared    buffers     cached
Mem:          2016       1973         42          0        163       1497
-/+ buffers/cache:        312       1703
Swap:         4094          0       4094
```

**第一部分Mem行解释：**

```
total：内存总数；
used：已经使用的内存数；
free：空闲的内存数；
shared：当前已经废弃不用；
buffers Buffer：缓存内存数；
cached Page：缓存内存数。
```

关系：total = used + free

**第二部分(-/+ buffers/cache)解释:**

```
(-buffers/cache) used内存数：第一部分Mem行中的 used – buffers – cached
(+buffers/cache) free内存数: 第一部分Mem行中的 free + buffers + cached
```

可见-buffers/cache反映的是被程序实实在在吃掉的内存，而+buffers/cache反映的是可以挪用的内存总数。

第三部分是指交换分区。

#### 23.进程

执行中的程序称作进程。当程序可以执行文件存放在存储中，并且运行的时候，每个进程会被动态得分配系统资源、内存、安全属性和与之相关的状态。可以有多个进程关联到同一个程序，并同时执行不会互相干扰。操作系统会有效地管理和追踪所有运行着的进程。

#### 24.列出所有运行中/激活进程

```
ps -a
```

#### 25.列出需要进程

```undefined
ps -ef |grep 
```

#### 26.以树状结构显示进程关系

```css
pstree 
```

#### 27.杀进程的命令

1、杀死 - 通过ID杀死一个进程

2、killall - 按名称杀死一个进程

#### 28.进程的状态

进程描述符(task_struct)中的state变量描述进程的当前状态。常见的状态如下：
1、TASK_RUNNING(运行状态)：表示进程是可执行的，它正在执行，或者在运行队列中等待执行。
2、TASK_INTERRUPTIBLE(可中断，也就是睡眠状态)：进程正在睡眠(也就是进程被阻塞)等待某些条件满足后才运行。
3、TASK_UNINTERRUPTIBLE(不可中断，磁盘休眠状态):除了不会因为接收到信号而被唤醒运行之外，他与可中断状态相同。在这个状态的进程通常会等待IO的结束。可以通过发送SIGSTOP信号给进程来停止进程，这个被暂停的进程可以通过发送SIGCONT信号让进程继续执行。
例：
停止进程：kill -SIGSTOP
继续运行：kill -SIGCONT

4、TASK_ZOMBIE(僵死状态)：该进程已经结束了，但是父进程还没有使用wait()系统调用。因为父进程不能读取到子进程退出的返回代码，所以就会产生僵死进程。为了父进程能够获知它的消息，子进程的进程描述符仍然被保留，一但父进程调用wait()，进程描述符就会被释放。

5、TASK_STOPPED(停止状态)：进程停止执行，进程不能投入运行。通常这种状态发生在接受到SIGSTOP、SIGTSTP、SIGTTIN、SIGOUT等信号的时候。此外，在调试期间接受到的任何信号，都会使进程进入这种状态。

#### 29.僵尸进程

当一个进程退出时，他并不是完全消失，而是等到它的符进程发出wait系统调用才会完全消失，除非父进程发出wait系统调用终止进程，否则该进程一直处于僵死状态，等待父进程终止它。
实际上，僵尸进程已经死了，它要向父进程返回一个退出状态，报告死讯。而父进程一直不进行wait系统调用的话，子进程就变成了僵尸进程。要消灭僵尸进程的话，先找到僵尸进程的父进程，杀死父进程，然后由init（进程号为1）消灭僵尸进程。init是所有进程的父进程。

#### 30.查看环境变量

1) 检查当前僵尸进程信息

```linux
ps -ef | grep defunct | grep -v grep | wc -l

　　175

top | head -2

　　top - 15:05:54 up 97 days, 23:49, 4 users, load average: 0.66, 0.45, 0.39
　　Tasks: 829 total, 1 running, 479 sleeping, 174 stopped, 175 zombie

ps -ef | grep defunct | grep -v grep
```

2) 获得杀僵尸进程语句

```linux
ps -ef | grep defunct | grep -v grep | awk '{print "kill -9 " $2,$3}'
```

执行上面获得的语句即可, 使用信号量9, 僵尸进程数会大大减少.
3) 过一会儿检查当前僵尸进程信息

```linux
ps -ef | grep defunct | grep -v grep | wc -l

　　125
　　top | head -2

　　top - 15:29:26 up 98 days, 12 min, 7 users, load average: 0.27, 0.54, 0.56
　　Tasks: 632 total, 1 running, 381 sleeping, 125 stopped, 125 zombie
```


　　发现僵尸进程数减少了一些, 但还有不少啊.
4) 再次获得杀僵尸进程语句

```
ps -ef | grep defunct | grep -v grep | awk '{print "kill -18 " $3}'

```

　　执行上面获得的语句即可, 这次使用信号量18杀其父进程, 僵尸进程应该会全部消失.
5) 过一会儿再检查当前僵尸进程信息

```linux
ps -ef | grep defunct | grep -v grep | wc -l

　　0

top | head -2

　　top - 15:39:46 up 98 days, 23 min, 7 users, load average: 5.46, 2.20, 1.12
　　Tasks: 134 total, 1 running, 133 sleeping, 0 stopped, 0 zombie
```

6) 清除ZOMBIE(僵尸)进程原理

kill -18 PPID

　　PPID是其父进程, 这个信号是告诉父进程, 该子进程已经死亡了, 请收回分配给他的资源.
　　如果还不行则看先看其父进程又无其他子进程, 如果有, 可能需要先kill其他子进程, 也就是兄弟进程.
方法是:

kill -15 PID1 PID2

　　PID1,PID2是僵尸进程的父进程的其它子进程.
　　然后再kill父进程:

kill -15 PPID                

#### 31.孤儿进程

如果父进程比子进程先死的话，子进程就变成孤儿进程了，这时候孤儿进程就被init（进程号为1）进程领养。并由init进程对他们完成状态收集工作。

#### 32.如何杀死某个进程

在做项目的时候经常会出现程序死机、锁死、无响应等情况，这时候就需要找到程序相应的进程将其杀掉即可。步骤如下：

**1. 定位进程**

top 命令：可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过 top 命令所提供的互动式界面，用热键可以管理。

输入 top 后可以看到如下的界面, 实时显示进程情况。



![img](https://img-blog.csdn.net/20180822133603685?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MzAzNzU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

ps 命令：process status 的简称，用于报告当前系统的进程状态。此命令长配合 grep 过滤输出结果，常用的结构：

```
ps -aux | grep ***
```



aux 选项如下所示：

a - 显示所有用户的进程

u - 显示进程的用户和拥有者

x - 显示不依附于终端的进程

举个例子，查看 python 相关的进程

![img](https://img-blog.csdn.net/20180822134207718?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MzAzNzU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



第一行数据解释从左到右）：

“ubuntu” 是用户；“14992” 是 PID；“0.0” 是 %CPU - 占用 CPU 的百分比；“0.4” 是 %MEM - 占用内存的百分比；

PID 就是我们要的



**2. 杀死进程**

我们可以通过 进程的名字和进程的 ID（PID）来结束进程。

结束命令：

kill：通过进程 ID 来结束进程

killall：通过进程名字结束进程

最长使用的结束进程的信号是：

| Signal Name | Single Value | Effect         |
| ----------- | ------------ | -------------- |
| SIGHUP      | 1            | 挂起           |
| SIGINT      | 2            | 键盘的中断信号 |
| SIGKILL     | 9            | 发出杀死信号   |
| SIGTERM     | 15           | 发出终止信号   |
| SIGSTOP     | 17, 19, 23   | 停止进程       |

我们可以通过 Single Value 的值来代替信号的名字。所以我们现在来杀死 python 进程：

```
kill SIGNAL PID
```

SIGNAL 是要发送的信号，PID 是进程号。

```
kill -9 14992
```

上面的命令就是杀死 python 进程的。如果有多个 python 程序在运行，想要全部结束的话，可以

```
killall -9 python
```

#### 参考链接

https://www.jianshu.com/p/2b2a7955a8ef

https://blog.csdn.net/qq_31278903/article/details/83146031

https://blog.csdn.net/u013616945/article/details/77435607

https://blog.51cto.com/ixdba/541355

https://blog.csdn.net/hguisu/article/details/6152921

https://blog.csdn.net/boenxia/article/details/89642006

https://www.linuxprobe.com/12linux-process-commands.html

https://blog.csdn.net/qq_31278903/article/details/83146031

https://www.linuxprobe.com/linux-kill-manager.html

https://blog.csdn.net/LF_2016/article/details/54577707

https://blog.51cto.com/petervip/956479

https://blog.csdn.net/qq_29303759/article/details/81942356
